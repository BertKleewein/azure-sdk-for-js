## API Report File for "@azure-tools/dtdl-parser-generator"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export class CodeWriter {
    constructor(filePath: string);
    // (undocumented)
    break(): void;
    // (undocumented)
    close(): void;
    // (undocumented)
    closeScope(): void;
    // (undocumented)
    openScope(suppressNewLine?: boolean): void;
    // (undocumented)
    writeLine(text: string, suppressNewLine?: boolean, suppressBreak?: boolean): void;
}

// @public (undocumented)
export class ParserCodeGenerator {
    // (undocumented)
    static execute(inputDigest: string, outputDirectory: string, _dtdlVersion: string): Promise<void>;
}

// @public (undocumented)
export function pascalToCamel(text: string): string;

// @public (undocumented)
export function pascalToSnake(text: string): string;

// @public
export enum TsAccess {
    // (undocumented)
    Private = "private",
    // (undocumented)
    Protected = "protected",
    // (undocumented)
    Public = "public"
}

// @public (undocumented)
export class TsCatch extends TsScope {
    constructor(err: string, nestingScope: TsScope);
    // (undocumented)
    finally(): TsFinally;
    // (undocumented)
    line(text: string): this;
}

// @public
export class TsClass extends TsDeclaration {
    constructor({ name, exports, abstract, inheritance, deferStaticInitialization }: TsClassParams);
    // (undocumented)
    get ctor(): TsConstructor;
    // (undocumented)
    deferStaticInitialization?: boolean;
    // (undocumented)
    field(input: TsFieldParams): TsClass;
    // (undocumented)
    fields: TsField[];
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    getter({ name, returnType, access, }: {
        name: string;
        returnType?: string;
        access?: TsAccess;
    }): TsMethod;
    // (undocumented)
    hasField(fieldName: string): boolean;
    // (undocumented)
    hasMethod(methodName: string): boolean;
    // (undocumented)
    importObject(objectName: string, location?: string): this;
    // (undocumented)
    inheritance?: TsInheritanceType[];
    // (undocumented)
    inline(filepath: string, identifier: string): void;
    // (undocumented)
    method(tsFunctionParams: TsFunctionParams): TsMethod;
    // (undocumented)
    setter({ name, returnType, access, }: {
        name: string;
        returnType?: string;
        access?: TsAccess;
    }): TsMethod;
    // (undocumented)
    get staticCtor(): TsConstructor;
    // (undocumented)
    get suffixCode(): TsMultiLine;
    // (undocumented)
    get tsConstructor(): TsConstructor | undefined;
}

// @public (undocumented)
export interface TsClassParams {
    // (undocumented)
    abstract?: boolean;
    // (undocumented)
    deferStaticInitialization?: boolean;
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    inheritance?: TsInheritanceType[];
    // (undocumented)
    name: string;
}

// @public (undocumented)
export class TsConstructor extends TsMethod {
    constructor(isStatic: boolean);
    // (undocumented)
    parameter(input: TsParameterParams): this;
    // (undocumented)
    super(inputs: string[]): TsScope;
}

// @public (undocumented)
export class TsDeclaration implements TsLibraryObject {
    constructor({ name, type, exports }: TsDeclarationParams);
    // (undocumented)
    get docString(): TsMultiLineDocString;
    // (undocumented)
    protected _exports: boolean;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get header(): TsMultiLine;
    // (undocumented)
    import(text: string): this;
    // (undocumented)
    importObject(objectName: string, location?: string): this;
    // (undocumented)
    protected _importStatements?: TsImport;
    // (undocumented)
    name: string;
    // (undocumented)
    get prefixCode(): TsMultiLine;
    // (undocumented)
    protected _type: TsDeclarationType;
}

// @public (undocumented)
export interface TsDeclarationParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    type: TsDeclarationType;
}

// @public (undocumented)
export enum TsDeclarationType {
    // (undocumented)
    Class = "class",
    // (undocumented)
    Enum = "enum",
    // (undocumented)
    Function = "function",
    // (undocumented)
    Interface = "interface",
    // (undocumented)
    TypeAlias = "typealias"
}

// @public (undocumented)
export class TsElse extends TsScope {
    constructor();
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsElseIf extends TsScope {
    constructor(text: string, nestingScope: TsScope);
    // (undocumented)
    else(): TsElse;
    // (undocumented)
    elseIf(text: string): TsElseIf;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsEnum {
    constructor({ name, exports }: TsEnumParams);
    // (undocumented)
    enum(input: {
        name: string;
        value?: string;
    }): TsEnum;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export interface TsEnumParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
}

// @public
export class TsField {
    constructor({ name, type, access, readonly, isStatic, summary, value, optional }: TsFieldParams);
    // (undocumented)
    access?: TsAccess;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    isStatic?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    readonly?: boolean;
    // (undocumented)
    summary?: string;
    // (undocumented)
    type: string;
    // (undocumented)
    value?: string;
}

// @public (undocumented)
export interface TsFieldParams {
    // (undocumented)
    access?: TsAccess;
    // (undocumented)
    isStatic?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    readonly?: boolean;
    // (undocumented)
    summary?: string;
    // (undocumented)
    type: string;
    // (undocumented)
    value?: any;
}

// @public (undocumented)
export class TsFinally extends TsScope {
    constructor();
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsFor extends TsScope {
    constructor(text: string);
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsForEach extends TsScope {
    constructor(text: string, parameters: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsFunction extends TsFunctionBase {
    constructor(tsFunctionParams: TsFunctionParams);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    import(text: string): this;
    // (undocumented)
    importObject(objectName: string, location?: string): this;
    // (undocumented)
    protected _importStatements?: TsImport;
}

// @public (undocumented)
export class TsFunctionBase implements TsStatement {
    constructor({ name, returnType, functionType, abstract, access, exports, isStatic, mightBeEmpty, }: TsFunctionParams);
    // (undocumented)
    get access(): TsAccess | undefined;
    // (undocumented)
    get body(): TsScope;
    // (undocumented)
    get exports(): boolean | undefined;
    // (undocumented)
    get funcName(): string;
    // (undocumented)
    get functionType(): TsFunctionType | undefined;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get isAbstract(): boolean | undefined;
    // (undocumented)
    get isStatic(): boolean | undefined;
    // (undocumented)
    libraryObject?: TsLibraryObject;
    // (undocumented)
    get name(): string;
    // (undocumented)
    parameter(tsParameterParams: TsParameterParams): this;
    // (undocumented)
    get parameters(): TsParameter[];
    // (undocumented)
    get returnType(): string | undefined;
    // (undocumented)
    summary(text: string): this;
    // (undocumented)
    get summaryLines(): TsMultiLineDocString | undefined;
}

// @public (undocumented)
export interface TsFunctionParams {
    // (undocumented)
    abstract?: boolean;
    // (undocumented)
    access?: TsAccess;
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    functionType?: TsFunctionType;
    // (undocumented)
    isStatic?: boolean;
    // (undocumented)
    mightBeEmpty?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    returnType?: string;
}

// @public (undocumented)
export enum TsFunctionType {
    // (undocumented)
    Function = "function",
    // (undocumented)
    Getter = "get",
    // (undocumented)
    Method = "method",
    // (undocumented)
    Setter = "set"
}

// @public (undocumented)
export class TsIf extends TsScope {
    constructor(text: string, nestingScope: TsScope);
    // (undocumented)
    else(): TsElse;
    // (undocumented)
    elseIf(text: string): TsElseIf;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsImport implements TsStatement {
    constructor();
    // (undocumented)
    addTsImport(text: string): void;
    // (undocumented)
    addTsImportObject(objectName: string, location?: string): void;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsImportGeneric implements TsStatement {
    constructor(text: string);
    // (undocumented)
    equals(other: TsStatement): boolean;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsImportObject implements TsStatement {
    constructor(objectName: string, location?: string);
    // (undocumented)
    equals(other: TsStatement): boolean;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export interface TsInheritanceType {
    // (undocumented)
    name: string | string[];
    // (undocumented)
    type: TsDeclarationType;
}

// @public (undocumented)
export class TsInline implements TsStatement {
    constructor(filepath: string, identifier: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsInterface extends TsDeclaration {
    constructor({ name, exports, thingToExtend }: TsInterfaceParams);
    // (undocumented)
    get extends(): string | undefined;
    // (undocumented)
    field(input: TsFieldParams): TsInterface;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    inline(filepath: string, identifier: string): void;
    // (undocumented)
    method({ name, returnType }: {
        name: string;
        returnType?: string;
    }): TsFunction;
}

// @public (undocumented)
export interface TsInterfaceParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    thingToExtend?: string;
}

// @public
export class TsLibrary {
    constructor(outputDir: string);
    // (undocumented)
    class(input: TsClassParams): TsClass;
    // (undocumented)
    enum(input: TsEnumParams): TsEnum;
    // (undocumented)
    function(input: TsFunctionParams): TsFunction;
    // (undocumented)
    generateFiles(): string[];
    // (undocumented)
    interface(input: TsInterfaceParams): TsInterface;
    // (undocumented)
    libraryHeader(text: string): TsMultiLine;
    // (undocumented)
    typeAlias(input: TsTypeAliasParams): TsTypeAlias;
}

// @public (undocumented)
export interface TsLibraryObject {
    // (undocumented)
    import(text: string): this;
    // (undocumented)
    importObject(objectName: string, location?: string): this;
}

// @public (undocumented)
export class TsLine implements TsStatement {
    constructor(text: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get text(): string;
}

// @public (undocumented)
export class TsLintSuppressor {
    // (undocumented)
    explicitModuleBoundaryTypes(): void;
    // (undocumented)
    noUnusedVars(): void;
    // (undocumented)
    toString(): string;
    // (undocumented)
    useInterfaceParameters(): void;
}

// @public (undocumented)
export class TsMethod extends TsFunctionBase {
    // (undocumented)
    importObject(objectName: string, location?: string): this;
}

// @public (undocumented)
export class TsMultiLine implements TsStatement {
    constructor(text?: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsMultiLineDocString extends TsMultiLine {
    constructor();
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsParameter {
    constructor({ name, type, description, initializer, optional, mightBeUnused, shouldBeInterface, mightBeAny, }: TsParameterParams);
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get name(): string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): string | undefined;
}

// @public (undocumented)
export interface TsParameterParams {
    // (undocumented)
    description?: string;
    // (undocumented)
    initializer?: string;
    // (undocumented)
    mightBeAny?: boolean;
    // (undocumented)
    mightBeUnused?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    shouldBeInterface?: boolean;
    // (undocumented)
    type?: string;
}

// @public (undocumented)
export class TsScope implements TsStatement {
    constructor(firstLine?: string, suppressBreak?: boolean);
    // (undocumented)
    protected _firstLine?: string;
    // (undocumented)
    for(text: string): TsFor;
    // (undocumented)
    forEach(object: string, cbParams: string): TsForEach;
    // (undocumented)
    function({ name, returnType, functionType, abstract, access, isStatic, }: TsFunctionParams): TsFunction;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    if(ifText: string): TsIf;
    // (undocumented)
    importObject(objectName: string, location?: string): this;
    // (undocumented)
    inline(filepath: string, identifier: string): void;
    // (undocumented)
    protected _inlines: TsInline[];
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    libraryObject?: TsLibraryObject;
    // (undocumented)
    line(text: string): TsScope;
    // (undocumented)
    multiLine(text: string): TsScope;
    // (undocumented)
    scope(firstLine: string): TsScope;
    // (undocumented)
    statement(tsStatement: TsStatement): void;
    // (undocumented)
    protected _statements: TsStatement[];
    // (undocumented)
    protected _suppressBreak: boolean;
    // (undocumented)
    try(): TsTry;
    // (undocumented)
    while(whileText: string): TsScope;
}

// @public (undocumented)
export interface TsStatement {
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsTry extends TsScope {
    constructor(nestingScope: TsScope);
    // (undocumented)
    catch(text: string): TsCatch;
    // (undocumented)
    finally(): TsFinally;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsTypeAlias extends TsDeclaration {
    constructor({ name, typeToBeAliased, exports }: TsTypeAliasParams);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export interface TsTypeAliasParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    typeToBeAliased: string;
}

// @public (undocumented)
export class TsWhile extends TsScope {
    constructor(text: string);
    // (undocumented)
    line(text: string): this;
}

// (No @packageDocumentation comment for this package)

```
